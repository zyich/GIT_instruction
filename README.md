# Работа с репозиторием
## Начало работы с Git
* **Первичная настройка Git**
Перед тем как вообще что-то можно будет сделать с помощью Git, после установки самой программы на ваше устройство необходимо, как минимум, "представиться" программе, задав ей своё Имя/Ник и электронную почту. А так же, проверить, установилась ли она вообще.
Сделать это можно в предоставленной установленной программе GitBash среде (по умолчанию, это Vim), или в Командной строке(Windows)/Теминале(MakOS, Lunix). Для этого понадобиться ввести нижеследующие команды.
```Bash
git --version
``` 
Отображает текущую версию Git, если она установилась успешно.
```Bash
git config --global <Имя/ник пользователя>
``` 
Это позволит программе запомнить ваше имя, от которого будут производиться все последующие коммиты.
```Bash
git config --global <user@email.com>
``` 
Ну а это позволит программе запомнить вашу электронную почту. 
Кстати, команда ниже позволяет посмотреть текущие настройки Git:
```Bash
git config --List
``` 
* **Инициализация**
Команда для инициализации текщей папки/директории в качестве репозитория.
Именно с этого начинается работа с репозиторием - вы его создаёте в определённом месте, что бы внутри отслеживать все последующие изменения.
Будьте винмательны при использовании этой команды и проверяйте текущее Ваше положение. Иначе, рискуете сделать репозиторием... всё. И это очень плохо.
```bash
git init
```
* **Навигация**
А как же перместиться к нужной директории, что бы там воспользоваться предыдущей командой и не испортить себе жизнь?
Для этого, если вы работаете не в среде с проводником, потребуется прописать путь к нужной папке, при этом, придёться учитывать особенности среды, в которой вы вводите команды. Поскольку команды относятся не к самому Git и являются стандартными для выбранной среды(Командной строки или Терминале, к примеру).
```bash
cd <путь>
```
Что бы подняться в дереве директорий на уровень выше, без прописывания всего пути:
```bash
cd ../
```
Что бы подняться в дереве директорий на *два* уровеня выше, без прописывания всего пути:
```bash
cd ../..
```
*(пожалуй, я не буду на этом моменте больше оснанавливаться, там команд ещё туча)*
* **Статус**
Говорят - *самая важная* команда Git. Позволяет проверить текущее состояние репозитория. Был ли он инициализрован в текущей папке вообще и находитесь ли в нём? 
Есть ли ещё не отслеживаемые директории и файлы(возможно вы что-то новое создали и перемстили в папку с репозиторием)? 
Есть ли уже модифицированный(изменённые) файлы требующие фиксации?
И ещё некоторые интересные моменты.
```bash
git status
```
## Работа с коммитами
* **Индексирование**
Прежде чем начинать работу с проектом и создавать свои первые коммиты, необходимо создать файлы проекта и, указать Git, что их необходимо отслеживать. Иначе, никакие изменения проводимые с ними, не будут фиксироваться. 
Что бы это сделать и проиндексировать новые *Созданые*, или добавленные в процессе файлы, необходимо, сделать, собственно, первый коммит (:
Для этого, первонаперво, необходимо "подготовить" файлы и папки, которые мы хотим отслеживать, к будущему коммиту.
По одному элементу, если вам нужнго добавить не все файлы и директории репозитория или конкретной подпапки.
```bash
git add <имя файла>
```
Или все разом. Но учтите, что добавлены буду только те файлы, что находяться в той папке, где вы находитесь, и во всех вложенных в неё директориях. По этому, наиболее целесообразно применять команду из корневой папки репозитория.
```bash
git add .
```
* **Commit**
И только после предшествующих действий применяется комманда *commit*. Не забывайте про комментарии к коммитам, что бы потом всегда можно было понять, что было сделанно на момент создания новго коммита. Будущий вы, за это будет вас благодарить с со лезами на глазах, после того как запорит вашу программу и ему придёться "откатиться" назад, когда всё ещё работало.
```bash
git commit -m "коментарий к коммиту"
```
Или просто:
```bash
git commit
```
**Но!** после этой команды, вас выбросит на спецэкран, где необходимо будет нажать на клавиатуре "i", что бы получить доступ к комментированию.
Потом, вписать коментарий и нажать "Esc", что бы выйти из режима редактирования. 
Что бы закончить и сохранить коммит, нужно нажать нажать ":" и, ввести "wq". После чего нажать "Enter/Ввод". 
Сложно, но для практики в работе с консольными средами - самое то.
* **Логи**
Команда раскрывает список изменений, т.е. всех коммитов сделанных в репозитории. С указанием изголовья и названием текущей ветки, из которой идёт запрос на логи.
Если вам нужен какой-то коммит из прошлого, что бы посмотреть как было раньше и как плохо вы сделали сейчас. То хэш-код нужных коммитов вы найдёте именно здесь. Конечно, если вы следовали совету и комментировали коммиты как пологается для упрощённой навигации по ним.
Кроме того, вы получите информацию о времени создания комита, кто его автор и куда слать гневные электронные писамь о его коде и... всё.
И да. Q - важная клавиша. (:
```bash
git log
```
* **Переход на коммит**
Если нужно перейти к старому коммиту ~~или сменить ветку репозитория~~, то просто наберите команду, а после хэш(многомного непонятных символов, который) заранее найденного коммита(можно просто 4-ре первых символа), ~~илибо имя ветки~~.
```bash
git checkout <хэш коммита>
```
* **Сравнение**
Если нужно посмотреть, чем текущий код отличается от того, что был при последнем коммите, то вам нужна команда:
```bash
git diff
```
## Работа с ветками
* **Создание новой ветки**
Для создания новой ветки, необходимо выбрать откуда будет происходить "отпочкование". Обычно это главная ветка masetr/main. Перейти на неё, если вы уже на ней не наодитесь.
После использовать команду с введением названия ветки(название ветки по хорошему должно отражать цель для которой она была создана)
```bash
git branch <НазваниеВетки>
```
Кстати, что бы просто просмотреть список существующих веток, нажно просто набрать (git branch), и всё. Вы увидите какие ветки существуют в работе, и на какой находитесь сейчас. Вот так:
```bash
git branch
```
Альтернативный способ. Позволяет сразу перейти на новую, созданную ветку.
```bash
git checkout -b <имя ветки>
```

* **Переход по веткам**

@@ -160,18 +164,82 @@ git branch -d <НазваниеВетки>
```bash
git log --graph
```
## Test-conflict
* **Рукотворный конфликт**
## Удалённый репозиторий
* **Клонирование _с_ удлённого репозитория** 

Для загрузки репозитория с GitHub или иного подобного ресурса на вашу рабочию машину, желательно создать директорию, в которую вы будите клонировать удалённый репозиторий, и после перемещения с помощью встроенного провдника рабочей среды или терминала/командной строки в ту папку, задать ниже слудующую команду, подставив заранее скопированную\полученную ссылку ввидете htmls или css. 

Важно! Для SSH требуется предварительная настройка, что будет расписанно позже.  
```bash
git clone <HTTPS\SSH>
```
* **Загрузка _на_ удалённый репозиторий**

Предварительно требуется созданть, жедательно одноимённый, новый пустой репозиторий на самом GitHub или ином подобном ресурсе. После чего, произвести последовательно ряд команд для установки связи локльного репозитория с удёлнным и синхронизации их главной ветки.

**Превое.** Преименование ветки. Ваша основная ветка и ветка на Github желательно должны носить одно название. Для этого, обычно дефолтный (master) переименовывают в дефолтный (main). Но, это рекоминдация не обязательна.
```bash
git branch -M <main>
```
**Второе.** Установка собственно связи локального репо, с удёлным. Для этого вам нужна ссылка на ваш новосозданный репозиторий. Её можно взять непосредственно при создании в стартовой странице помощи.
```bash
git remote add origin <HTTPS\SSH>
```
**Третье.** Теперь уже загружаем сосбвтенно сам репозиторий на удалёнку. Важно помнить о названии ветки. Вы ведь могли и не менять (master) или вообще использовать своё авторское название главной ветки. А именно его и нужно использовать в последующей комманде.
```bash
git push -u origin <имя ветки>
```
Однако, эта же команда позволяет загрузить в общем-то любую ветку, создав её на удалённом репозитории.
* **Работа с удалённым репозиторием**

Простой и быстрый способ подтянуть последнюю версиютекущего проекта с удалённого репозитория.
```bash
git pull
```
Безопасный способ сделать то же самое. Команда подтянет информацию о последнем коммите, ХЭШ которого будет отражён в появившейся после команды информации(последняя строка). Используя его можно перейти и на последний коммит и посмотреть текущие последние состояние репозитория.

В случаи конфликта веток, когда существует в разных ветках сразу, разные изменения(контент), придёться в ручную разгребать, что оставить, что выкинуть, или всё оставить. Графические интерфейсы(VS Code, к примеру), в этом плане, намного удобней и наглядней.
Если всё хорошо, то можно использовать команду git merge <origin/main> ~~(или другую ветку?)~~
```bash
git fetch
```
Если установлена связть локльной с удалённой веткой, то для того что бы залить на удалённый репозиторий свой последний коммит, то можно использовать просто:
```bash
git push 
```

* **PULL REQUEST**

_Что бы сделать пулрек в своём проекте._

Создаёшь доп ветку. Работаешь. Кидаешь ветку на Github. Заходишь на него. Он предлагает зафигачить доп. ветку в основной при помощи pull request (если не предлагает, то топаешь в одноимённый раздел и делаешь его в ручную). Если нет конфликотов, то радуешься, есои нет, то мучиешься, решаешь конфликт и потом радуешься.

_Что бы сделать пулрек в чужой проект_

Сделать Fork чужого проекта, создав копию у себя в репозитории. Его склонировать на комп. По уму, просто потом создаёшь доп ветку, в ней работаешь, пушиш в свою копию, и так точно так же тебе GitHub предлагает сделать пул реквест, но уже в хозяйский проект. Делаешь, если принимают, то радуешься, Если нет, то дорабатываешь в соответсвии с коментариями.

И так. Чёто-то я не понял, с чего в конфликте у меня участвовал значительный кусок текста, который вообще не должен был в нём участвовать. Пробуем ещё раз.
Может, стоит сделать более подробно.

Ещё раз. Предыдущий Конфликт был не очень удачно и наглядно сделан. Но зато, в нём уже не было проблемы с задействованный лишним текстом.
Скриншоты:

![скрин fork](fork.png)

Какой-то текст для наглядного конфликта для 3-го теста.
![скрин pull request](pullrequest.png)

Всё Ок. 
#
**Прмечание.** _Ветки удалять не буду, не потому что не знаю или забыл, а что бы можно было на них переключиться и посмотреть всё что с ними творилось отдельно._
* **Дополнительные команды**

Проверить, есть ли у локального репозитория с вязь с удалёнными, и если да, то с какими.
```bash
git remote 
```
Предоставляет ту же, но более развёрнутую информацию о связи с удалёнными репозиториями.
```bash
git remote -v
```
Показывает связь лолкльных веток с ветками на удалённых репозиториях.
```bash
git branch -vv
```
Показывает вообще все локальные и удалённые ветки репозитория.
```bash
git branch -a
```
